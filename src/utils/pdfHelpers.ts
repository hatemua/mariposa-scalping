import PDFDocument from 'pdfkit';

// Color scheme
export const COLORS = {
  primary: '#1e40af', // Blue
  success: '#10b981', // Green
  danger: '#ef4444', // Red
  warning: '#f59e0b', // Yellow
  neutral: '#6b7280', // Gray
  background: '#f9fafb',
  text: '#111827',
  textLight: '#6b7280',
  border: '#e5e7eb'
};

// Font sizes
export const FONTS = {
  title: 24,
  heading: 18,
  subheading: 14,
  body: 11,
  small: 9,
  tiny: 8
};

/**
 * Add page header
 */
export function addPageHeader(
  doc: PDFKit.PDFDocument,
  title: string,
  date: Date,
  pageNumber?: number
): void {
  const startY = doc.page.margins.top - 30;

  doc
    .fontSize(FONTS.heading)
    .fillColor(COLORS.primary)
    .font('Helvetica-Bold')
    .text(title, doc.page.margins.left, startY, { align: 'left' });

  if (pageNumber) {
    doc
      .fontSize(FONTS.small)
      .fillColor(COLORS.textLight)
      .font('Helvetica')
      .text(
        `Page ${pageNumber}`,
        doc.page.width - doc.page.margins.right - 100,
        startY + 5,
        { align: 'right', width: 100 }
      );
  }

  // Draw line
  doc
    .strokeColor(COLORS.border)
    .lineWidth(1)
    .moveTo(doc.page.margins.left, startY + 25)
    .lineTo(doc.page.width - doc.page.margins.right, startY + 25)
    .stroke();

  doc.moveDown(2);
}

/**
 * Add page footer
 */
export function addPageFooter(
  doc: PDFKit.PDFDocument,
  pageNum: number,
  totalPages: number
): void {
  const footerY = doc.page.height - doc.page.margins.bottom + 10;

  doc
    .fontSize(FONTS.tiny)
    .fillColor(COLORS.textLight)
    .font('Helvetica')
    .text(
      `Generated by Mariposa Scalping Bot | ${new Date().toLocaleString('en-US', {
        dateStyle: 'medium',
        timeStyle: 'short'
      })} UTC`,
      doc.page.margins.left,
      footerY,
      { align: 'center', width: doc.page.width - doc.page.margins.left - doc.page.margins.right }
    );

  doc
    .fontSize(FONTS.small)
    .fillColor(COLORS.text)
    .text(
      `${pageNum} / ${totalPages}`,
      doc.page.width - doc.page.margins.right - 50,
      footerY,
      { align: 'right', width: 50 }
    );
}

/**
 * Draw a section header
 */
export function addSectionHeader(
  doc: PDFKit.PDFDocument,
  icon: string,
  title: string,
  subtitle?: string
): void {
  doc
    .fontSize(FONTS.heading)
    .fillColor(COLORS.primary)
    .font('Helvetica-Bold')
    .text(`${icon} ${title}`, { continued: false });

  if (subtitle) {
    doc
      .fontSize(FONTS.small)
      .fillColor(COLORS.textLight)
      .font('Helvetica')
      .text(subtitle);
  }

  doc.moveDown(0.5);
}

/**
 * Draw a table
 */
export function drawTable(
  doc: PDFKit.PDFDocument,
  data: any[][],
  columns: Array<{ header: string; width: number; align?: 'left' | 'center' | 'right' }>,
  startX: number,
  startY: number
): number {
  const rowHeight = 25;
  const headerHeight = 30;
  let currentY = startY;

  // Draw header
  let currentX = startX;
  doc.fillColor(COLORS.primary).rect(startX, currentY, columns.reduce((sum, col) => sum + col.width, 0), headerHeight).fill();

  columns.forEach(col => {
    doc
      .fontSize(FONTS.small)
      .fillColor('#ffffff')
      .font('Helvetica-Bold')
      .text(col.header, currentX + 5, currentY + 8, {
        width: col.width - 10,
        align: col.align || 'left'
      });
    currentX += col.width;
  });

  currentY += headerHeight;

  // Draw rows
  data.forEach((row, rowIndex) => {
    currentX = startX;
    const fillColor = rowIndex % 2 === 0 ? '#ffffff' : COLORS.background;
    doc.fillColor(fillColor).rect(startX, currentY, columns.reduce((sum, col) => sum + col.width, 0), rowHeight).fill();

    columns.forEach((col, colIndex) => {
      doc
        .fontSize(FONTS.body)
        .fillColor(COLORS.text)
        .font('Helvetica')
        .text(String(row[colIndex] || ''), currentX + 5, currentY + 7, {
          width: col.width - 10,
          align: col.align || 'left'
        });
      currentX += col.width;
    });

    currentY += rowHeight;

    // Check if we need a new page
    if (currentY > doc.page.height - doc.page.margins.bottom - 50) {
      doc.addPage();
      currentY = doc.page.margins.top;
    }
  });

  return currentY;
}

/**
 * Draw a progress bar
 */
export function drawProgressBar(
  doc: PDFKit.PDFDocument,
  x: number,
  y: number,
  width: number,
  value: number,
  max: number,
  color?: string
): void {
  const height = 12;
  const percentage = Math.min((value / max) * 100, 100);
  const fillWidth = (width * percentage) / 100;

  // Determine color based on value
  let barColor = color || COLORS.primary;
  if (!color) {
    if (percentage >= 70) barColor = COLORS.success;
    else if (percentage >= 40) barColor = COLORS.warning;
    else barColor = COLORS.danger;
  }

  // Background
  doc
    .fillColor(COLORS.border)
    .rect(x, y, width, height)
    .fill();

  // Filled portion
  doc
    .fillColor(barColor)
    .rect(x, y, fillWidth, height)
    .fill();

  // Border
  doc
    .strokeColor(COLORS.border)
    .lineWidth(1)
    .rect(x, y, width, height)
    .stroke();

  // Percentage text
  doc
    .fontSize(FONTS.tiny)
    .fillColor(COLORS.text)
    .font('Helvetica-Bold')
    .text(`${percentage.toFixed(0)}%`, x + width + 5, y + 2);
}

/**
 * Draw a badge
 */
export function drawBadge(
  doc: PDFKit.PDFDocument,
  x: number,
  y: number,
  text: string,
  type: 'success' | 'danger' | 'warning' | 'info' = 'info'
): number {
  const colors = {
    success: { bg: COLORS.success, text: '#ffffff' },
    danger: { bg: COLORS.danger, text: '#ffffff' },
    warning: { bg: COLORS.warning, text: '#ffffff' },
    info: { bg: COLORS.primary, text: '#ffffff' }
  };

  const color = colors[type];
  const padding = 8;
  const height = 18;

  // Measure text width
  const textWidth = doc.fontSize(FONTS.small).font('Helvetica-Bold').widthOfString(text);
  const width = textWidth + padding * 2;

  // Draw rounded rectangle
  doc
    .fillColor(color.bg)
    .roundedRect(x, y, width, height, 3)
    .fill();

  // Draw text
  doc
    .fontSize(FONTS.small)
    .fillColor(color.text)
    .font('Helvetica-Bold')
    .text(text, x + padding, y + 4, { width: textWidth });

  return width;
}

/**
 * Draw a key-value pair
 */
export function drawKeyValue(
  doc: PDFKit.PDFDocument,
  x: number,
  y: number,
  key: string,
  value: string,
  valueColor?: string
): void {
  doc
    .fontSize(FONTS.body)
    .fillColor(COLORS.textLight)
    .font('Helvetica')
    .text(`${key}:`, x, y);

  const keyWidth = doc.widthOfString(`${key}: `);

  doc
    .fillColor(valueColor || COLORS.text)
    .font('Helvetica-Bold')
    .text(value, x + keyWidth, y);
}

/**
 * Draw a box with border
 */
export function drawBox(
  doc: PDFKit.PDFDocument,
  x: number,
  y: number,
  width: number,
  height: number,
  borderColor?: string,
  fillColor?: string
): void {
  if (fillColor) {
    doc.fillColor(fillColor).rect(x, y, width, height).fill();
  }

  doc
    .strokeColor(borderColor || COLORS.border)
    .lineWidth(1)
    .rect(x, y, width, height)
    .stroke();
}

/**
 * Format number as currency
 */
export function formatCurrency(value: number, decimals: number = 2): string {
  return `$${value.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals })}`;
}

/**
 * Format number as percentage
 */
export function formatPercentage(value: number, decimals: number = 1): string {
  const sign = value >= 0 ? '+' : '';
  return `${sign}${value.toFixed(decimals)}%`;
}

/**
 * Get risk level color
 */
export function getRiskColor(riskLevel: string): string {
  switch (riskLevel.toUpperCase()) {
    case 'LOW':
      return COLORS.success;
    case 'MEDIUM':
      return COLORS.warning;
    case 'HIGH':
      return COLORS.danger;
    default:
      return COLORS.neutral;
  }
}

/**
 * Get recommendation color
 */
export function getRecommendationColor(recommendation: string): string {
  switch (recommendation.toUpperCase()) {
    case 'BUY':
      return COLORS.success;
    case 'SELL':
      return COLORS.danger;
    case 'HOLD':
      return COLORS.warning;
    default:
      return COLORS.neutral;
  }
}

/**
 * Word wrap text
 */
export function wrapText(
  doc: PDFKit.PDFDocument,
  text: string,
  x: number,
  y: number,
  maxWidth: number,
  fontSize: number = FONTS.body
): number {
  doc.fontSize(fontSize).font('Helvetica');

  const words = text.split(' ');
  let line = '';
  let currentY = y;
  const lineHeight = fontSize * 1.2;

  words.forEach(word => {
    const testLine = line + word + ' ';
    const testWidth = doc.widthOfString(testLine);

    if (testWidth > maxWidth && line !== '') {
      doc.text(line.trim(), x, currentY);
      line = word + ' ';
      currentY += lineHeight;
    } else {
      line = testLine;
    }
  });

  if (line !== '') {
    doc.text(line.trim(), x, currentY);
    currentY += lineHeight;
  }

  return currentY;
}

/**
 * Add page break if needed
 */
export function checkPageBreak(doc: PDFKit.PDFDocument, requiredSpace: number): boolean {
  if (doc.y + requiredSpace > doc.page.height - doc.page.margins.bottom) {
    doc.addPage();
    return true;
  }
  return false;
}
